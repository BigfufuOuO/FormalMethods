File "exp2/au2.pv", line 82, characters 19-21:
Warning: identifier sid rebound.
File "exp2/au2.pv", line 121, characters 9-11:
Warning: identifier sid rebound.
File "exp2/au2.pv", line 155, character 21:
Warning: identifier b rebound.
File "exp2/au2.pv", line 157, character 21:
Warning: identifier B rebound.
Linear part:
exponent(exponent(g_,a),b) = exponent(exponent(g_,b),a)
Completing equations...
Completed equations:
exponent(exponent(g_,a),b) = exponent(exponent(g_,b),a)
Convergent part: No equation.
Process 0 (that is, the initial process):
{1}new SAT_id: id;
{2}new AP_id: id;
{3}new AS_id: id;
{4}new SAT_sk: skey;
{5}new AP_sk: skey;
{6}new AS_sk: skey;
{7}new AS_ssk: sskey;
{8}new macSAT: macAddress;
{9}new macAP: macAddress;
{10}let SAT_pk: pkey = spk(SAT_sk) in
{11}out(c, SAT_pk);
{12}let AP_pk: pkey = spk(AP_sk) in
{13}out(c, AP_pk);
{14}let AS_pk: pkey = spk(AS_sk) in
{15}out(c, AS_pk);
{16}let certSAT: cert = certificat(SAT_id,SAT_pk,sign2cert(SAT_id,SAT_pk,AS_ssk)) in
{17}let certAP: cert = certificat(AP_id,AP_pk,sign2cert(AP_id,AP_pk,AS_ssk)) in
{18}let certAS: cert = certificat(AS_id,AS_pk,sign2cert(AS_id,AS_pk,AS_ssk)) in
(
    {19}let SAT_id_1: id = SAT_id in
    {20}let SAT_sk_1: skey = SAT_sk in
    {21}let macSAT_1: macAddress = macSAT in
    {22}let certificat(AS_id_1: id,AS_pk_1: pkey,certSignAS: certSign) = certAS in
    {23}in(c, msg1: message);
    {24}let Process1((sid_1: nonce,certAP_1: cert)) = msg1 in
    {25}let certificat(AP_id_1: id,AP_pk_1: pkey,certSignAP: certSign) = certAP_1 in
    {26}event SAT_sid(SAT_id_1,sid_1);
    {27}new challengeSAT: nonce;
    {28}new a: ex;
    {29}new g: G;
    {30}let A: G = exponent(g,a) in
    {31}let signSAT: bitstring = sign2m((sid_1,AP_id_1,challengeSAT,certSAT,A,g),SAT_sk_1) in
    {32}out(c, Process2((sid_1,AP_id_1,challengeSAT,certSAT,signSAT,A,g)));
    {33}in(c, msg5: message);
    {34}let Process5((rAP_id: id,rSAT_id: id,rchallengeAP: nonce,rchallengeSAT: nonce,rB: G,rA: G,rresponse: nat,rmsg4: message,rsignAP: bitstring)) = msg5 in
    {35}let Process4((ADDID(ASmacAP: macAddress,ASmacSAT: macAddress),ASchallengeAP: nonce,ASchallengeSAT: nonce,AScheckAP: nonce,AScheckSAT: nat,AScertAP: nat,AScertSAT: cert,ASsignAS: bitstring)) = rmsg4 in
    {36}if ((rSAT_id = SAT_id_1) && ((rAP_id = AP_id_1) && ((challengeSAT = rchallengeSAT) && (rA = A)))) then
    {37}if (checksign((rAP_id,rSAT_id,rchallengeAP,rchallengeSAT,rB,rA,rresponse,rmsg4),rsignAP,AP_pk_1) = pass) then
    {38}if (rresponse = 1) then
    {39}if (checksign((ADDID(ASmacAP,ASmacSAT),ASchallengeAP,ASchallengeSAT,AScheckAP,AScheckSAT,AScertAP,AScertSAT,ASsignAS),ASsignAS,AS_pk_1) = pass) then
    {40}let SAT_bk: bkey = HashMac_BK(exponent(rB,a),rchallengeAP,rchallengeSAT) in
    {41}let SAT_nextid: nonce = SHA256(HashMac_nonce(exponent(rB,a),rchallengeAP,rchallengeSAT)) in
    {42}event SAT_bk_generate(SAT_id_1,SAT_bk);
    {43}event SAT_nextid_generate(SAT_id_1,SAT_nextid)
) | (
    {44}let AP_id_2: id = AP_id in
    {45}let AP_sk_1: skey = AP_sk in
    {46}let macAP_1: macAddress = macAP in
    {47}let macSAT_2: macAddress = macSAT in
    {48}new sid_2: nonce;
    {49}new g_1: G;
    {50}new b: ex;
    {51}let B: G = exponent(g_1,b) in
    {52}let msg1_1: message = Process1((sid_2,certAP)) in
    {53}out(c, msg1_1);
    {54}event AP_sid_sent(AP_id_2,sid_2);
    {55}in(c, msg2: message);
    {56}let Process2((msid: nonce,mid: id,mchallenge: nonce,mcertSAT: cert,msignSAT: bitstring,mA: G,mg: G)) = msg2 in
    {57}let certificat(SAT_id_2: id,SAT_pk_1: pkey,certSAT_1: certSign) = mcertSAT in
    {58}if ((msid = sid_2) && ((mid = AP_id_2) && (mg = g_1))) then
    {59}if (checksign((msid,mid,mchallenge,mcertSAT,mA,mg),msignSAT,SAT_pk_1) = pass) then
    {60}new challengeAP: nonce;
    {61}let msg3: message = Process3((ADDID(macAP_1,macSAT_2),challengeAP,mchallenge,certAP,certSAT_1)) in
    {62}out(c, msg3);
    {63}in(c, msg4: message);
    {64}let Process4((ADDID(ASmacAP_1: macAddress,ASmacSAT_1: macAddress),ASchallengeAP_1: nonce,ASchallengeSAT_1: nonce,AScheckAP_1: nat,AScheckSAT_1: nat,AScertAP_1: cert,AScertSAT_1: cert,ASsignAS_1: bitstring)) = msg4 in
    {65}let certificat(AS_id_2: id,AS_pk_2: pkey,certSignAS_1: certSign) = certAS in
    {66}if (checksign((ADDID(ASmacAP_1,ASmacSAT_1),ASchallengeAP_1,ASchallengeSAT_1,AScheckAP_1,AScheckSAT_1,AScertAP_1,AScertSAT_1),ASsignAS_1,AS_pk_2) = pass) then
    {67}if ((AScheckAP_1 = 1) && (AScheckSAT_1 = 1)) then
    {68}new b_1: ex;
    {69}let response: nat = 1 in
    {70}let B_1: G = exponent(g_1,b_1) in
    {71}let AP_bk: bkey = HashMac_BK(exponent(mA,b_1),challengeAP,mchallenge) in
    {72}let AP_nextid: nonce = SHA256(HashMac_nonce(exponent(mA,b_1),challengeAP,mchallenge)) in
    {73}event AP_bk_generate(AP_id_2,AP_bk);
    {74}event AP_nextid_generate(AP_id_2,AP_nextid);
    {75}let signAP: bitstring = sign2m((AP_id_2,SAT_id_2,challengeAP,mchallenge,B_1,mA,response,msg4),AP_sk_1) in
    {76}let msg5_1: message = Process5((AP_id_2,SAT_id_2,challengeAP,mchallenge,B_1,mA,response,msg4,signAP)) in
    {77}out(c, msg5_1)
) | (
    {78}let AS_id_3: id = AS_id in
    {79}let AS_sk_1: skey = AS_sk in
    {80}let AS_ssk_1: sskey = AS_ssk in
    {81}in(c, msg3_1: message);
    {82}let Process3((ADDID(macAP_2: macAddress,macSAT_3: macAddress),challengeAP_1: nonce,challengeSAT_1: nonce,certAP_2: cert,certSAT_2: cert)) = msg3_1 in
    {83}if (checkcert(certAP_2,cpk(AS_ssk_1)) = pass) then
    {84}let checkAP: nat = 1 in
    {85}if (checkcert(certSAT_2,cpk(AS_ssk_1)) = pass) then
    {86}let checkSAT: nat = 1 in
    {87}if ((checkAP = 1) && (checkSAT = 1)) then
    {88}let signAS: bitstring = sign2m((ADDID(macAP_2,macSAT_3),challengeAP_1,challengeSAT_1,checkAP,checkSAT,certAP_2,certSAT_2),AS_sk_1) in
    {89}let msg4_1: message = Process4((ADDID(macAP_2,macSAT_3),challengeAP_1,challengeSAT_1,checkAP,checkSAT,certAP_2,certSAT_2,signAS)) in
    {90}out(c, msg4_1)
)

File "exp2/au2.pv", line 75, characters 28-30:
Warning: identifier sid rebound.
--  Process 1 (that is, process 0, encoded for secret AP_nextid, secret AP_bk, secret SAT_nextid, secret SAT_bk, with let moved downwards):
{1}new SAT_id: id;
{2}new AP_id: id;
{3}new AS_id: id;
{4}new SAT_sk: skey;
{5}new AP_sk: skey;
{6}new AS_sk: skey;
{7}new AS_ssk: sskey;
{8}new macSAT: macAddress;
{9}new macAP: macAddress;
{10}let SAT_pk: pkey = spk(SAT_sk) in
{11}out(c, SAT_pk);
{12}let AP_pk: pkey = spk(AP_sk) in
{13}out(c, AP_pk);
{14}let AS_pk: pkey = spk(AS_sk) in
{15}out(c, AS_pk);
{18}let certAS: cert = certificat(AS_id,AS_pk,sign2cert(AS_id,AS_pk,AS_ssk)) in
(
    {22}let certificat(AS_id_1: id,AS_pk_1: pkey,certSignAS: certSign) = certAS in
    {23}in(c, msg1: message);
    {24}let Process1((sid_1: nonce,certAP_1: cert)) = msg1 in
    {25}let certificat(AP_id_1: id,AP_pk_1: pkey,certSignAP: certSign) = certAP_1 in
    {19}let SAT_id_1: id = SAT_id in
    {26}event SAT_sid(SAT_id_1,sid_1);
    {27}new challengeSAT: nonce;
    {28}new a: ex;
    {29}new g: G;
    {30}let A: G = exponent(g,a) in
    {20}let SAT_sk_1: skey = SAT_sk in
    {16}let certSAT: cert = certificat(SAT_id,SAT_pk,sign2cert(SAT_id,SAT_pk,AS_ssk)) in
    {31}let signSAT: bitstring = sign2m((sid_1,AP_id_1,challengeSAT,certSAT,A,g),SAT_sk_1) in
    {32}out(c, Process2((sid_1,AP_id_1,challengeSAT,certSAT,signSAT,A,g)));
    {33}in(c, msg5: message);
    {34}let Process5((rAP_id: id,rSAT_id: id,rchallengeAP: nonce,rchallengeSAT: nonce,rB: G,rA: G,rresponse: nat,rmsg4: message,rsignAP: bitstring)) = msg5 in
    {35}let Process4((ADDID(ASmacAP: macAddress,ASmacSAT: macAddress),ASchallengeAP: nonce,ASchallengeSAT: nonce,AScheckAP: nonce,AScheckSAT: nat,AScertAP: nat,AScertSAT: cert,ASsignAS: bitstring)) = rmsg4 in
    {36}if ((rSAT_id = SAT_id_1) && ((rAP_id = AP_id_1) && ((challengeSAT = rchallengeSAT) && (rA = A)))) then
    {37}if (checksign((rAP_id,rSAT_id,rchallengeAP,rchallengeSAT,rB,rA,rresponse,rmsg4),rsignAP,AP_pk_1) = pass) then
    {38}if (rresponse = 1) then
    {39}if (checksign((ADDID(ASmacAP,ASmacSAT),ASchallengeAP,ASchallengeSAT,AScheckAP,AScheckSAT,AScertAP,AScertSAT,ASsignAS),ASsignAS,AS_pk_1) = pass) then
    {40}let SAT_bk: bkey = HashMac_BK(exponent(rB,a),rchallengeAP,rchallengeSAT) in
    {41}event SAT_bk_contains(SAT_bk);
    {42}let SAT_nextid: nonce = SHA256(HashMac_nonce(exponent(rB,a),rchallengeAP,rchallengeSAT)) in
    {43}event SAT_nextid_contains(SAT_nextid);
    {44}event SAT_bk_generate(SAT_id_1,SAT_bk);
    {45}event SAT_nextid_generate(SAT_id_1,SAT_nextid)
) | (
    {50}new sid_2: nonce;
    {51}new g_1: G;
    {52}new b: ex;
    {17}let certAP: cert = certificat(AP_id,AP_pk,sign2cert(AP_id,AP_pk,AS_ssk)) in
    {54}let msg1_1: message = Process1((sid_2,certAP)) in
    {55}out(c, msg1_1);
    {46}let AP_id_2: id = AP_id in
    {56}event AP_sid_sent(AP_id_2,sid_2);
    {57}in(c, msg2: message);
    {58}let Process2((msid: nonce,mid: id,mchallenge: nonce,mcertSAT: cert,msignSAT: bitstring,mA: G,mg: G)) = msg2 in
    {59}let certificat(SAT_id_2: id,SAT_pk_1: pkey,certSAT_1: certSign) = mcertSAT in
    {60}if ((msid = sid_2) && ((mid = AP_id_2) && (mg = g_1))) then
    {61}if (checksign((msid,mid,mchallenge,mcertSAT,mA,mg),msignSAT,SAT_pk_1) = pass) then
    {62}new challengeAP: nonce;
    {49}let macSAT_2: macAddress = macSAT in
    {48}let macAP_1: macAddress = macAP in
    {63}let msg3: message = Process3((ADDID(macAP_1,macSAT_2),challengeAP,mchallenge,certAP,certSAT_1)) in
    {64}out(c, msg3);
    {65}in(c, msg4: message);
    {66}let Process4((ADDID(ASmacAP_1: macAddress,ASmacSAT_1: macAddress),ASchallengeAP_1: nonce,ASchallengeSAT_1: nonce,AScheckAP_1: nat,AScheckSAT_1: nat,AScertAP_1: cert,AScertSAT_1: cert,ASsignAS_1: bitstring)) = msg4 in
    {67}let certificat(AS_id_2: id,AS_pk_2: pkey,certSignAS_1: certSign) = certAS in
    {68}if (checksign((ADDID(ASmacAP_1,ASmacSAT_1),ASchallengeAP_1,ASchallengeSAT_1,AScheckAP_1,AScheckSAT_1,AScertAP_1,AScertSAT_1),ASsignAS_1,AS_pk_2) = pass) then
    {69}if ((AScheckAP_1 = 1) && (AScheckSAT_1 = 1)) then
    {70}new b_1: ex;
    {73}let AP_bk: bkey = HashMac_BK(exponent(mA,b_1),challengeAP,mchallenge) in
    {74}event AP_bk_contains(AP_bk);
    {75}let AP_nextid: nonce = SHA256(HashMac_nonce(exponent(mA,b_1),challengeAP,mchallenge)) in
    {76}event AP_nextid_contains(AP_nextid);
    {77}event AP_bk_generate(AP_id_2,AP_bk);
    {78}event AP_nextid_generate(AP_id_2,AP_nextid);
    {72}let B_1: G = exponent(g_1,b_1) in
    {71}let response: nat = 1 in
    {47}let AP_sk_1: skey = AP_sk in
    {79}let signAP: bitstring = sign2m((AP_id_2,SAT_id_2,challengeAP,mchallenge,B_1,mA,response,msg4),AP_sk_1) in
    {80}let msg5_1: message = Process5((AP_id_2,SAT_id_2,challengeAP,mchallenge,B_1,mA,response,msg4,signAP)) in
    {81}out(c, msg5_1)
) | (
    {85}in(c, msg3_1: message);
    {86}let Process3((ADDID(macAP_2: macAddress,macSAT_3: macAddress),challengeAP_1: nonce,challengeSAT_1: nonce,certAP_2: cert,certSAT_2: cert)) = msg3_1 in
    {84}let AS_ssk_1: sskey = AS_ssk in
    {87}if (checkcert(certAP_2,cpk(AS_ssk_1)) = pass) then
    {89}if (checkcert(certSAT_2,cpk(AS_ssk_1)) = pass) then
    {90}let checkSAT: nat = 1 in
    {88}let checkAP: nat = 1 in
    {91}if ((checkAP = 1) && (checkSAT = 1)) then
    {83}let AS_sk_1: skey = AS_sk in
    {92}let signAS: bitstring = sign2m((ADDID(macAP_2,macSAT_3),challengeAP_1,challengeSAT_1,checkAP,checkSAT,certAP_2,certSAT_2),AS_sk_1) in
    {93}let msg4_1: message = Process4((ADDID(macAP_2,macSAT_3),challengeAP_1,challengeSAT_1,checkAP,checkSAT,certAP_2,certSAT_2,signAS)) in
    {94}out(c, msg4_1)
)

-- Query secret SAT_bk encoded as not (event(SAT_bk_contains(v)) && attacker(v)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 128 rules (49 with conclusion selected). Queue: 6 rules.
Starting query secret SAT_bk
RESULT secret SAT_bk is true.
-- Query secret SAT_nextid encoded as not (event(SAT_nextid_contains(v)) && attacker(v)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 128 rules (49 with conclusion selected). Queue: 6 rules.
Starting query secret SAT_nextid
RESULT secret SAT_nextid is true.
-- Query secret AP_bk encoded as not (event(AP_bk_contains(v)) && attacker(v)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 139 rules (49 with conclusion selected). Queue: 16 rules.
Starting query secret AP_bk
RESULT secret AP_bk is true.
-- Query secret AP_nextid encoded as not (event(AP_nextid_contains(v)) && attacker(v)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 139 rules (49 with conclusion selected). Queue: 16 rules.
Starting query secret AP_nextid
RESULT secret AP_nextid is true.
-- Query inj-event(SAT_bk_generate(SAT_id_3,bk)) ==> inj-event(AP_bk_generate(SAT_id_3,bk)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 138 rules (49 with conclusion selected). Queue: 16 rules.
Starting query inj-event(SAT_bk_generate(SAT_id_3,bk)) ==> inj-event(AP_bk_generate(SAT_id_3,bk))
RESULT inj-event(SAT_bk_generate(SAT_id_3,bk)) ==> inj-event(AP_bk_generate(SAT_id_3,bk)) is true.
-- Query inj-event(SAT_nextid_generate(SAT_id_3,nextid)) ==> inj-event(AP_nextid_generate(SAT_id_3,nextid)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 138 rules (49 with conclusion selected). Queue: 16 rules.
Starting query inj-event(SAT_nextid_generate(SAT_id_3,nextid)) ==> inj-event(AP_nextid_generate(SAT_id_3,nextid))
RESULT inj-event(SAT_nextid_generate(SAT_id_3,nextid)) ==> inj-event(AP_nextid_generate(SAT_id_3,nextid)) is true.
-- Query inj-event(SAT_sid(SAT_id_3,sid_3)) ==> inj-event(AP_sid_sent(AP_id_3,sid_3)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 131 rules (50 with conclusion selected). Queue: 6 rules.
Starting query inj-event(SAT_sid(SAT_id_3,sid_3)) ==> inj-event(AP_sid_sent(AP_id_3,sid_3))
goal reachable: attacker(sid_3) && attacker(AP_id_3) && attacker(AP_pk_2) && attacker(certSignAP_1) -> inj-event(SAT_sid(SAT_id[],sid_3),@occ26_1)
Abbreviations:
@occ26_1 = @occ26[msg1 = Process1((sid_3,certificat(AP_id_3,AP_pk_2,certSignAP_1)))]

Derivation:
Abbreviations:
@occ26_1 = @occ26[msg1 = Process1((sid_3,certificat(AP_id_3,AP_pk_2,certSignAP_1)))]

1. We assume as hypothesis that
attacker(certSignAP_1).

2. We assume as hypothesis that
attacker(AP_pk_2).

3. We assume as hypothesis that
attacker(AP_id_3).

4. By 3, the attacker may know AP_id_3.
By 2, the attacker may know AP_pk_2.
By 1, the attacker may know certSignAP_1.
Using the function certificat the attacker may obtain certificat(AP_id_3,AP_pk_2,certSignAP_1).
attacker(certificat(AP_id_3,AP_pk_2,certSignAP_1)).

5. We assume as hypothesis that
attacker(sid_3).

6. By 5, the attacker may know sid_3.
By 4, the attacker may know certificat(AP_id_3,AP_pk_2,certSignAP_1).
Using the function 2-tuple the attacker may obtain (sid_3,certificat(AP_id_3,AP_pk_2,certSignAP_1)).
attacker((sid_3,certificat(AP_id_3,AP_pk_2,certSignAP_1))).

7. By 6, the attacker may know (sid_3,certificat(AP_id_3,AP_pk_2,certSignAP_1)).
Using the function Process1 the attacker may obtain Process1((sid_3,certificat(AP_id_3,AP_pk_2,certSignAP_1))).
attacker(Process1((sid_3,certificat(AP_id_3,AP_pk_2,certSignAP_1)))).

8. The message Process1((sid_3,certificat(AP_id_3,AP_pk_2,certSignAP_1))) that the attacker may have by 7 may be received at input {23}.
So event SAT_sid(SAT_id[],sid_3) may be executed at {26}.
inj-event(SAT_sid(SAT_id[],sid_3),@occ26_1).

9. By 8, inj-event(SAT_sid(SAT_id[],sid_3),@occ26_1).
The goal is reached, represented in the following fact:
inj-event(SAT_sid(SAT_id[],sid_3),@occ26_1).


A more detailed output of the traces is available with
  set traceDisplay = long.

new SAT_id: id creating SAT_id_3 at {1}

new AP_id: id creating AP_id_4 at {2}

new AS_id: id creating AS_id_4 at {3}

new SAT_sk: skey creating SAT_sk_2 at {4}

new AP_sk: skey creating AP_sk_2 at {5}

new AS_sk: skey creating AS_sk_2 at {6}

new AS_ssk: sskey creating AS_ssk_2 at {7}

new macSAT: macAddress creating macSAT_4 at {8}

new macAP: macAddress creating macAP_3 at {9}

out(c, ~M) with ~M = spk(SAT_sk_2) at {11}

out(c, ~M_1) with ~M_1 = spk(AP_sk_2) at {13}

out(c, ~M_2) with ~M_2 = spk(AS_sk_2) at {15}

new sid_2: nonce creating sid_4 at {50}

new g_1: G creating g_2 at {51}

new b: ex creating b_2 at {52}

out(c, Process1((~M_3,certificat(~M_4,~M_5,~M_6)))) with ~M_3 = sid_4, ~M_4 = AP_id_4, ~M_5 = spk(AP_sk_2), ~M_6 = sign2cert(AP_id_4,spk(AP_sk_2),AS_ssk_2) at {55}

in(c, Process1((a_1,certificat(a_2,a_3,a_4)))) at {23}

event SAT_sid(SAT_id_3,a_1) at {26} (goal)

The event SAT_sid(SAT_id_3,a_1) is executed at {26}.
A trace has been found.
RESULT inj-event(SAT_sid(SAT_id_3,sid_3)) ==> inj-event(AP_sid_sent(AP_id_3,sid_3)) is false.
RESULT (even event(SAT_sid(SAT_id_3,sid_3)) ==> event(AP_sid_sent(AP_id_3,sid_3)) is false.)

--------------------------------------------------------------
Verification summary:

Query secret SAT_bk is true.

Query secret SAT_nextid is true.

Query secret AP_bk is true.

Query secret AP_nextid is true.

Query inj-event(SAT_bk_generate(SAT_id_3,bk)) ==> inj-event(AP_bk_generate(SAT_id_3,bk)) is true.

Query inj-event(SAT_nextid_generate(SAT_id_3,nextid)) ==> inj-event(AP_nextid_generate(SAT_id_3,nextid)) is true.

Query inj-event(SAT_sid(SAT_id_3,sid_3)) ==> inj-event(AP_sid_sent(AP_id_3,sid_3)) is false.

--------------------------------------------------------------

